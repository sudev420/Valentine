<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Constellation for Soline</title>
  <style>
    :root {
      --bg0: #05030e;
      --bg1: #07051a;
      --bg2: #04020b;

      --ink: #eef0ff;
      --muted: rgba(238, 240, 255, .72);

      --glass: rgba(255, 255, 255, .08);
      --line: rgba(255, 255, 255, .14);

      --accent: #a855f7;
      --accent2: #22d3ee;
      --accent3: #f472b6;

      --shadow: 0 28px 90px rgba(0, 0, 0, .55);
      --shadow2: 0 14px 28px rgba(0, 0, 0, .45);
    }

    * {
      box-sizing: border-box
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color: var(--ink);
      background:
        radial-gradient(1100px 700px at 18% 16%, rgba(168, 85, 247, .06), transparent 58%),
        radial-gradient(1100px 700px at 78% 20%, rgba(34, 211, 238, .04), transparent 58%),
        radial-gradient(1200px 900px at 50% 80%, rgba(244, 114, 182, .03), transparent 62%),
        linear-gradient(180deg, var(--bg0), var(--bg1) 50%, var(--bg2));
      overflow: hidden;
    }

    .wrap {
      min-height: 100vh;
      display: grid;
      place-items: center;
      padding: 18px;
      position: relative;
    }

    .shell {
      width: min(1040px, 96vw);
      display: grid;
      grid-template-columns: 380px 1fr;
      gap: 16px;
      align-items: stretch;
    }

    @media (max-width: 980px) {
      body {
        overflow: auto
      }

      .shell {
        grid-template-columns: 1fr
      }
    }

    .panel {
      border-radius: 26px;
      background: linear-gradient(180deg, rgba(255, 255, 255, .10), rgba(255, 255, 255, .06));
      backdrop-filter: blur(14px);
      border: 1px solid var(--line);
      box-shadow: var(--shadow);
      padding: 16px;
    }

    h1 {
      margin: 0;
      font-size: clamp(26px, 3.2vw, 38px);
      letter-spacing: .2px;
    }

    p {
      margin: 10px 0 0 0;
      color: var(--muted);
      line-height: 1.45;
      font-size: 14px;
    }

    .statRow {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 14px;
      align-items: center;
    }

    .pill {
      background: rgba(255, 255, 255, .10);
      border: 1px solid rgba(255, 255, 255, .14);
      border-radius: 999px;
      padding: 10px 12px;
      font-weight: 850;
      box-shadow: var(--shadow2);
      user-select: none;
      white-space: nowrap;
    }

    .btn {
      border: 0;
      border-radius: 999px;
      padding: 10px 12px;
      font-weight: 860;
      cursor: pointer;
      background: rgba(255, 255, 255, .10);
      color: var(--ink);
      border: 1px solid rgba(255, 255, 255, .14);
      box-shadow: var(--shadow2);
      transition: transform .12s ease, filter .12s ease;
    }

    .btn:hover {
      filter: brightness(1.06);
    }

    .btn:active {
      transform: translateY(1px);
    }

    .primary {
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      color: #071021;
      border: 0;
      box-shadow: 0 18px 44px rgba(168, 85, 247, .22), 0 18px 44px rgba(34, 211, 238, .12);
    }

    .sky {
      border-radius: 26px;
      box-shadow: var(--shadow);
      border: 1px solid rgba(255, 255, 255, .14);
      overflow: hidden;
      position: relative;
      min-height: 660px;
      background:
        radial-gradient(1000px 700px at 30% 0%, rgba(168, 85, 247, .05), transparent 58%),
        radial-gradient(1000px 700px at 85% 10%, rgba(34, 211, 238, .04), transparent 58%),
        radial-gradient(900px 700px at 50% 85%, rgba(244, 114, 182, .03), transparent 62%),
        linear-gradient(180deg, #04020d, #080624 45%, #03010b);
    }

    .nebula {
      position: absolute;
      inset: -25%;
      background:
        radial-gradient(circle at 20% 30%, rgba(168, 85, 247, .04), transparent 45%),
        radial-gradient(circle at 70% 20%, rgba(34, 211, 238, .03), transparent 45%),
        radial-gradient(circle at 55% 75%, rgba(244, 114, 182, .02), transparent 50%);
      filter: blur(10px);
      opacity: .95;
      pointer-events: none;
    }

    .vignette {
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 50% 35%, transparent 35%, rgba(0, 0, 0, .55) 92%);
      pointer-events: none;
      opacity: .86;
    }

    canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      cursor: crosshair;
      touch-action: manipulation;
    }

    .hint {
      position: absolute;
      left: 14px;
      top: 14px;
      background: rgba(255, 255, 255, .10);
      border: 1px solid rgba(255, 255, 255, .14);
      border-radius: 999px;
      padding: 10px 12px;
      font-weight: 850;
      box-shadow: var(--shadow2);
      user-select: none;
      pointer-events: none;
    }

    .toast {
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      background: rgba(8, 10, 22, .88);
      border: 1px solid rgba(255, 255, 255, .14);
      color: #fff;
      padding: 10px 12px;
      border-radius: 999px;
      font-size: 13px;
      opacity: 0;
      pointer-events: none;
      transition: opacity .22s ease, transform .22s ease;
      z-index: 30;
      box-shadow: var(--shadow2);
    }

    .toast.show {
      opacity: 1;
      transform: translateX(-50%) translateY(-6px);
    }

    /* Unlock card */
    .card {
      margin-top: 14px;
      border-radius: 22px;
      border: 1px solid rgba(255, 255, 255, .14);
      background: rgba(255, 255, 255, .08);
      padding: 14px;
      display: none;
      position: relative;
      overflow: hidden;
    }

    .card.show {
      display: block;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(255, 255, 255, .10);
      border: 1px solid rgba(255, 255, 255, .14);
      box-shadow: var(--shadow2);
      font-weight: 900;
    }

    .badgeDot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      box-shadow: 0 0 18px rgba(34, 211, 238, .22);
    }

    .cardTitle {
      margin: 12px 0 0 0;
      font-size: 18px;
      font-weight: 950;
      letter-spacing: .2px;
    }

    .cardText {
      margin: 8px 0 0 0;
      color: rgba(238, 240, 255, .78);
      line-height: 1.5;
      font-size: 14px;
      font-weight: 650;
    }

    .floaties {
      position: absolute;
      inset: 0;
      pointer-events: none;
      overflow: hidden;
      opacity: .95;
    }

    .f {
      position: absolute;
      font-size: 18px;
      opacity: 0;
      animation: floatUp 3.8s linear infinite;
      filter: drop-shadow(0 0 14px rgba(244, 114, 182, .18));
    }

    @keyframes floatUp {
      0% {
        transform: translateY(40px) scale(.9);
        opacity: 0;
      }

      12% {
        opacity: .95;
      }

      100% {
        transform: translateY(-260px) scale(1.2);
        opacity: 0;
      }
    }

    /* Copy fallback modal */
    .modalBackdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, .40);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 18px;
      z-index: 60;
    }

    .modalBackdrop.show {
      display: flex;
    }

    .modal {
      width: min(640px, 96vw);
      background: linear-gradient(180deg, rgba(255, 255, 255, .12), rgba(255, 255, 255, .07));
      backdrop-filter: blur(16px);
      border: 1px solid rgba(255, 255, 255, .16);
      border-radius: 26px;
      box-shadow: 0 30px 110px rgba(0, 0, 0, .55);
      padding: 18px;
      position: relative;
      overflow: hidden;
    }

    .modalHeader {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 12px;
    }

    .modalTitle {
      margin: 0;
      font-size: 16px;
      font-weight: 950;
      letter-spacing: .2px;
    }

    .modalHint {
      margin: 10px 0 0 0;
      color: rgba(238, 240, 255, .74);
      font-size: 13px;
      line-height: 1.35;
    }

    .modalClose {
      border-radius: 999px;
      padding: 10px 12px;
      font-weight: 860;
      border: 1px solid rgba(255, 255, 255, .16);
      background: rgba(255, 255, 255, .10);
      color: var(--ink);
      cursor: pointer;
    }

    .copyArea {
      width: 100%;
      min-height: 160px;
      resize: vertical;
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, .18);
      background: rgba(0, 0, 0, .22);
      color: rgba(238, 240, 255, .92);
      padding: 12px;
      font-size: 14px;
      line-height: 1.45;
      outline: none;
      margin-top: 12px;
    }

    .srOnly {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="shell">
      <section class="panel">
        <h1>Connect the brightest stars</h1>
        <p>
          Click stars to draw line and make constellations. Connect the <b>7 brightest stars</b> to unlock a message.
        </p>

        <div class="statRow">
          <div class="pill" id="progressPill">0 of 7 connected</div>
          <button class="btn" id="undoBtn" type="button">Undo</button>
          <button class="btn" id="resetBtn" type="button">Reset</button>
          <button class="btn" id="shuffleBtn" type="button">Shuffle sky</button>
        </div>

        <div class="card" id="unlockCard">
          <div class="floaties" id="floaties"></div>
          <div class="badge"><span class="badgeDot"></span> unlocked</div>
          <div class="cardTitle">Happy 4th day of the love month, Soline.</div>
          <div class="cardText">
            Some stars only make sense when they are connected. Like us.
          </div>
          <div class="statRow" style="margin-top:12px">
            <button class="btn primary" id="celebrateBtn" type="button">Aww</button>
            <button class="btn" id="copyBtn" type="button">Copy message</button>
          </div>
        </div>

        <span class="srOnly" id="a11y"></span>
      </section>

      <section class="sky">
        <div class="nebula"></div>
        <div class="vignette"></div>
        <div class="hint" id="hint">click stars to connect</div>
        <canvas id="skyCanvas"></canvas>
      </section>
    </div>
  </div>

  <div class="toast" id="toast">Unlocked</div>

  <div class="modalBackdrop" id="modalBackdrop" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
    <div class="modal">
      <div class="modalHeader">
        <div>
          <p class="modalTitle" id="modalTitle">Copy this message</p>
          <p class="modalHint">If one click copy is blocked, select the text and copy with Cmd+C or Ctrl+C.</p>
        </div>
        <button class="modalClose" id="modalClose" type="button">Close</button>
      </div>
      <textarea class="copyArea" id="copyArea" readonly></textarea>
      <div class="statRow" style="justify-content:flex-end; margin-top:12px">
        <button class="btn" id="selectAllBtn" type="button">Select all</button>
        <button class="btn primary" id="tryCopyBtn" type="button">Try copy again</button>
      </div>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById("skyCanvas");
      const ctx = canvas.getContext("2d");

      const progressPill = document.getElementById("progressPill");
      const undoBtn = document.getElementById("undoBtn");
      const resetBtn = document.getElementById("resetBtn");
      const shuffleBtn = document.getElementById("shuffleBtn");
      const unlockCard = document.getElementById("unlockCard");
      const celebrateBtn = document.getElementById("celebrateBtn");
      const copyBtn = document.getElementById("copyBtn");
      const toast = document.getElementById("toast");
      const a11y = document.getElementById("a11y");
      const floaties = document.getElementById("floaties");

      const modalBackdrop = document.getElementById("modalBackdrop");
      const modalClose = document.getElementById("modalClose");
      const copyArea = document.getElementById("copyArea");
      const selectAllBtn = document.getElementById("selectAllBtn");
      const tryCopyBtn = document.getElementById("tryCopyBtn");

      const TARGET = 7;
      const STAR_COUNT = 70;

      const MESSAGE =
        "Happy 3rd day of the love month, Soline. Some stars only make sense when they are connected. Like us.";

      let w = 0, h = 0, dpr = 1;

      let stars = [];
      let selected = [];         // list of star indices clicked (sequence)
      let edges = [];            // pairs of indices
      let connectedBright = new Set();
      let brightIds = new Set();
      let unlocked = false;

      function rand(min, max) { return Math.random() * (max - min) + min; }
      function pick(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

      function resize() {
        const rect = canvas.getBoundingClientRect();
        dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        w = Math.floor(rect.width * dpr);
        h = Math.floor(rect.height * dpr);
        canvas.width = w;
        canvas.height = h;
        draw();
      }

      function makeStars() {
        stars = [];
        const margin = 40;
        for (let i = 0; i < STAR_COUNT; i++) {
          const x = rand(margin, (w / dpr) - margin);
          const y = rand(margin, (h / dpr) - margin);
          const base = rand(0.35, 1.0);
          const r = rand(0.9, 2.2) * (base + 0.2);
          const tw = rand(0.2, 0.9);
          stars.push({ x, y, base, r, tw });
        }

        // pick the 7 "brightest" stars by assigning higher base to 7 of them
        const idxs = Array.from({ length: STAR_COUNT }, (_, i) => i);
        idxs.sort(() => Math.random() - 0.5);

        brightIds = new Set(idxs.slice(0, TARGET));
        for (const i of brightIds) {
          stars[i].base = rand(1.25, 1.7);
          stars[i].r = rand(2.2, 3.3);
          stars[i].tw = rand(0.6, 1.0);
        }

        // Slightly dim some others for contrast
        for (let i = 0; i < STAR_COUNT; i++) {
          if (!brightIds.has(i)) {
            stars[i].base *= rand(0.75, 0.95);
          }
        }
      }

      function clearState() {
        selected = [];
        edges = [];
        connectedBright = new Set();
        unlocked = false;
        unlockCard.classList.remove("show");
        floaties.innerHTML = "";
        updateProgress();
      }

      function showToast(text) {
        toast.textContent = text;
        toast.classList.add("show");
        clearTimeout(showToast.t);
        showToast.t = setTimeout(() => toast.classList.remove("show"), 950);
      }

      function updateProgress() {
        progressPill.textContent = `${Math.min(connectedBright.size, TARGET)} of ${TARGET} connected`;
        if (connectedBright.size >= TARGET && !unlocked) {
          unlocked = true;
          unlockCard.classList.add("show");
          showToast("Unlocked");
          a11y.textContent = "Unlocked message.";
          startFloaties();
        }
      }

      function startFloaties() {
        floaties.innerHTML = "";
        const n = 18;
        for (let i = 0; i < n; i++) {
          const el = document.createElement("div");
          el.className = "f";
          el.textContent = pick(["âœ¨", "ðŸ’—", "ðŸ’–", "ðŸ’˜", "âœ¦", "âœ§", "ðŸ’•"]);
          el.style.left = rand(0, 100) + "%";
          el.style.bottom = "-20px";
          el.style.animationDelay = rand(0, 2.2) + "s";
          el.style.fontSize = Math.floor(rand(16, 26)) + "px";
          floaties.appendChild(el);
        }
      }

      function findStar(mx, my) {
        // mx,my are in CSS pixels
        let best = -1;
        let bestD = 999999;
        for (let i = 0; i < stars.length; i++) {
          const s = stars[i];
          const dx = s.x - mx;
          const dy = s.y - my;
          const d = Math.hypot(dx, dy);
          const hit = brightIds.has(i) ? 22 : 16;
          if (d < hit && d < bestD) {
            best = i;
            bestD = d;
          }
        }
        return best;
      }

      function addSelection(i) {
        if (i < 0) return;

        // If first click, just select star
        if (selected.length === 0) {
          selected.push(i);
          if (brightIds.has(i)) connectedBright.add(i);
          a11y.textContent = "Star selected.";
          updateProgress();
          draw();
          return;
        }

        const last = selected[selected.length - 1];
        if (i === last) {
          // clicking same star does nothing
          return;
        }

        // add edge
        edges.push([last, i]);
        selected.push(i);

        // count bright stars that have been touched at least once
        if (brightIds.has(i)) connectedBright.add(i);
        if (brightIds.has(last)) connectedBright.add(last);

        updateProgress();
        draw();
      }

      function undo() {
        if (selected.length === 0) return;
        if (selected.length === 1) {
          selected = [];
          edges = [];
        } else {
          selected.pop();
          edges.pop();
        }

        // recompute bright connections
        connectedBright = new Set();
        for (const idx of selected) {
          if (brightIds.has(idx)) connectedBright.add(idx);
        }
        updateProgress();
        draw();
      }

      function resetAll() {
        clearState();
        draw();
        showToast("Reset");
        a11y.textContent = "Reset.";
      }

      function shuffleSky() {
        makeStars();
        clearState();
        draw();
        showToast("Shuffled");
        a11y.textContent = "Shuffled sky.";
      }

      function drawBackground() {
        // faint dust
        ctx.save();
        ctx.globalAlpha = 0.18;
        for (let i = 0; i < 180; i++) {
          const x = Math.random() * w;
          const y = Math.random() * h;
          const r = Math.random() * 1.6 + 0.2;
          ctx.fillStyle = "rgba(255,255,255,.7)";
          ctx.beginPath();
          ctx.arc(x, y, r, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }

      function draw() {
        if (!w || !h) return;
        ctx.clearRect(0, 0, w, h);

        // background speckle (stable-ish per draw would flicker; keep light)
        // We'll avoid full redraw noise each frame. Just a subtle gradient overlay via canvas.
        // stars and lines are enough.

        // draw edges
        ctx.save();
        ctx.lineWidth = 2.2 * dpr;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";

        for (const [a, b] of edges) {
          const A = stars[a], B = stars[b];
          const aBright = brightIds.has(a);
          const bBright = brightIds.has(b);

          // color blend
          const stroke = (aBright || bBright) ? "rgba(34,211,238,.78)" : "rgba(255,255,255,.32)";
          ctx.strokeStyle = stroke;
          ctx.shadowColor = (aBright || bBright) ? "rgba(34,211,238,.35)" : "rgba(255,255,255,.12)";
          ctx.shadowBlur = (aBright || bBright) ? 18 * dpr : 8 * dpr;

          ctx.beginPath();
          ctx.moveTo(A.x * dpr, A.y * dpr);
          ctx.lineTo(B.x * dpr, B.y * dpr);
          ctx.stroke();
        }
        ctx.restore();

        // draw stars
        const t = performance.now() / 1000;
        for (let i = 0; i < stars.length; i++) {
          const s = stars[i];
          const tw = (Math.sin(t * (0.9 + s.tw) + i) * 0.5 + 0.5);
          const isBright = brightIds.has(i);
          const isSelected = selected.includes(i);

          const r = (s.r * (0.86 + tw * 0.28)) * dpr;

          ctx.save();
          // glow
          if (isBright) {
            ctx.shadowColor = "rgba(168,85,247,.35)";
            ctx.shadowBlur = (18 + tw * 14) * dpr;
          } else {
            ctx.shadowColor = "rgba(255,255,255,.14)";
            ctx.shadowBlur = 10 * dpr;
          }

          // fill
          let fill = "rgba(255,255,255,.78)";
          if (isBright) fill = "rgba(255,255,255,.92)";
          if (isSelected) fill = "rgba(255,255,255,1)";
          ctx.fillStyle = fill;

          ctx.beginPath();
          ctx.arc(s.x * dpr, s.y * dpr, r, 0, Math.PI * 2);
          ctx.fill();

          // ring on bright
          if (isBright) {
            ctx.shadowBlur = 0;
            ctx.strokeStyle = isSelected ? "rgba(244,114,182,.85)" : "rgba(34,211,238,.55)";
            ctx.lineWidth = (isSelected ? 2.0 : 1.4) * dpr;
            ctx.beginPath();
            ctx.arc(s.x * dpr, s.y * dpr, (r + 6 * dpr), 0, Math.PI * 2);
            ctx.stroke();
          }

          ctx.restore();
        }
      }

      // Animate twinkles
      let raf = 0;
      function tick() {
        draw();
        raf = requestAnimationFrame(tick);
      }

      // Copy handling
      async function tryClipboardWrite(text) {
        if (!navigator.clipboard || typeof navigator.clipboard.writeText !== "function") {
          return { ok: false };
        }
        try {
          await navigator.clipboard.writeText(text);
          return { ok: true };
        } catch {
          return { ok: false };
        }
      }

      function legacyCopy(text) {
        const ta = document.createElement("textarea");
        ta.value = text;
        ta.setAttribute("readonly", "");
        ta.style.position = "fixed";
        ta.style.top = "-1000px";
        ta.style.left = "-1000px";
        document.body.appendChild(ta);
        ta.focus();
        ta.select();
        let ok = false;
        try { ok = document.execCommand && document.execCommand("copy"); } catch { ok = false; }
        document.body.removeChild(ta);
        return ok;
      }

      function openCopyModal() {
        copyArea.value = MESSAGE;
        modalBackdrop.classList.add("show");
        setTimeout(() => { copyArea.focus(); copyArea.select(); }, 0);
      }
      function closeCopyModal() {
        modalBackdrop.classList.remove("show");
        copyBtn.focus();
      }

      modalClose.addEventListener("click", closeCopyModal);
      modalBackdrop.addEventListener("click", (e) => { if (e.target === modalBackdrop) closeCopyModal(); });
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && modalBackdrop.classList.contains("show")) closeCopyModal();
      });

      selectAllBtn.addEventListener("click", () => {
        copyArea.focus();
        copyArea.select();
      });

      tryCopyBtn.addEventListener("click", async () => {
        const r = await tryClipboardWrite(copyArea.value);
        if (r.ok) { showToast("Copied"); closeCopyModal(); return; }
        const ok = legacyCopy(copyArea.value);
        if (ok) { showToast("Copied"); closeCopyModal(); return; }
        showToast("Copy manually");
      });

      copyBtn.addEventListener("click", async () => {
        const r = await tryClipboardWrite(MESSAGE);
        if (r.ok) { showToast("Copied"); return; }
        const ok = legacyCopy(MESSAGE);
        if (ok) { showToast("Copied"); return; }
        openCopyModal();
      });

      // Interactions
      canvas.addEventListener("click", (e) => {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        const idx = findStar(mx, my);
        if (idx >= 0) {
          addSelection(idx);
        }
      });

      // Touch support: tap
      canvas.addEventListener("touchstart", (e) => {
        if (!e.touches || !e.touches[0]) return;
        const t = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        const mx = t.clientX - rect.left;
        const my = t.clientY - rect.top;
        const idx = findStar(mx, my);
        if (idx >= 0) {
          addSelection(idx);
        }
      }, { passive: true });

      undoBtn.addEventListener("click", () => { undo(); showToast("Undo"); });
      resetBtn.addEventListener("click", resetAll);
      shuffleBtn.addEventListener("click", shuffleSky);

      celebrateBtn.addEventListener("click", () => {
        showToast("ðŸ’˜");
        alert("Happy 3rd day of the love month, Soline.");
      });

      // init
      function init() {
        resize();
        makeStars();
        clearState();
        cancelAnimationFrame(raf);
        tick();
      }

      window.addEventListener("resize", () => {
        resize();
      });

      init();
    })();
  </script>
</body>

</html>